-- a) e1 (x,y) = (y, x)
--   e1 :: (a, b) -> (b, a)
--   Любой тип, т.к. просто меняются значения в кортеже
-- b) e2 (x, y) = y x
--   e2 :: (t1, t1 -> t2) -> t2
--   На "y" накладывается ограничение: 
--   y :: x -> a
--   поскольку "y" как бы "применяется" к "x"
-- c) e3 (x, y) = x y
--   e3 :: (t1 -> t2, t1) -> t2
--   Аналогично b) -- на "x" накладывается ограничение:
--   x :: y -> a
--   по аналогичным причинам
-- d) e4 x y = y x
--   e4 :: t1 -> (t1 -> t2) -> t2
--   Тут уже требуется, чтобы
--   y :: x -> a
--   т. к. "y" как бы "применяется" к "x"
-- e) e5 x y = x y x
--   Неформально говоря,
--              тип x                       тип y
--   e5 :: (func (func x -> t2) -> t1) -> (func x -> t2) -> t1
--   Тип x задан рекурсивно, причем это бесконечная рекурсия. Haskell ругается на это,
--   поэтому данный код не будет отработан
